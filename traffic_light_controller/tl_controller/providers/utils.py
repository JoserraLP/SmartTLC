# UTILS

import math
import random

import pandas as pd

from tl_controller.static.constants import *


def parse_str_to_valid_schema(input_info):
    return str(input_info).replace('\'', '\"').replace(" ", "")


def get_topology_dim(traci):
    """
    Retrieve the dimensions of the network topology. Only one number representing both dimensions as it is a regular
    topology matrix

    :param traci: TraCI instance
    :return dict with TL ids and its controlled lanes
    :rtype int
    """
    # Retrieve those valid edges (without ':' character as those are generated by sumo in junctions)
    valid_edges = [x for x in traci.edge.getIDList() if ":" not in x]

    # Retrieve number of north (or south) edges to retrieve number of cols
    # (divided by two as there are to edges per road)
    cols = len([x for x in valid_edges if "n" in x]) / 2
    # Retrieve number of west (or west) edges to retrieve number of rows
    # (divided by two as there are to edges per road)
    rows = len([x for x in valid_edges if "w" in x]) / 2

    return int(rows), int(cols)


def get_all_controlled_lanes(traci):
    """
    Retrieve all the controlled lanes by the different traffic lights.

    :param traci: TraCI instance
    :return dict with TL ids and its controlled lanes
    :rtype dict
    """
    return {tl_id: list(dict.fromkeys(traci.trafficlight.getControlledLanes(tl_id)))
            for tl_id in traci.trafficlight.getIDList()}


def get_all_detectors(traci):
    """
    Retrieve all the detectors.

    :param traci: TraCI instance
    :return list with the detectors
    :rtype list
    """
    return traci.inductionloop.getIDList()


def get_traffic_light_number(traci):
    """
    Retrieve the number of traffic lights in the simulation.

    :param traci: TraCI instance
    :return: number of traffic lights
    :rtype: int
    """
    return len(traci.trafficlight.getIDList())


def get_total_waiting_time_per_lane(traci):
    """
    Retrieve the waiting time of each lane related to each traffic lights.

    :param traci: TraCI instance
    :return: dict with the TL id and the waiting time per each controlled lane
    :rtype: dict
    """
    # Retrieve lanes
    lanes = get_all_controlled_lanes(traci)

    # Initialize the dict
    lanes_waiting_time = {}

    # Iterate over the different lanes
    for tl_id, tl_lanes in lanes.items():
        # Create the dict per each traffic light
        lanes_waiting_time[tl_id] = {}

        # Calculate and store the waiting time per lane
        for lane in tl_lanes:
            lanes_waiting_time[tl_id][lane] = traci.lane.getWaitingTime(lane)

    return lanes_waiting_time


def get_num_passing_vehicles_detectors(traci, vehicles_passed: dict):
    """
    Retrieve the number of vehicles passing detectors on each direction related to each traffic lights.

    :param vehicles_passed: dict with set of ids of the vehicles that has been counted per traffic light
    :type vehicles_passed: dict
    :param traci: TraCI instance
    :return: dict with the direction and the number of vehicle passing per each controlled lane
    :rtype: dict
    """
    # Retrieve detectors
    detectors = get_all_detectors(traci)

    # Create a dict with the accumulate of vehicles per direction
    passing_veh = {traffic_light: {'north': 0,
                                   'east': 0,
                                   'south': 0,
                                   'west': 0} for traffic_light
                   in traci.trafficlight.getIDList()}

    # Iterate over the detectors
    for detector in detectors:

        # Get traffic light name = lane name
        detector_tl = traci.inductionloop.getLaneID(detector).split('_')[1]

        # Get detector direction
        detector_direction = detector.split('_')[0]

        # Get the current passing vehicles
        cur_veh = set(traci.inductionloop.getLastStepVehicleIDs(detector))

        # Calculate the difference between the sets
        not_counted_veh = cur_veh - vehicles_passed[detector_tl]

        # If there are no counted vehicles
        if not_counted_veh:
            # Add the not counted vehicles
            vehicles_passed[detector_tl].update(not_counted_veh)

            passing_veh[detector_tl][detector_direction] += len(not_counted_veh)

    return passing_veh


def get_new_vehicles(traci):
    """
    Retrieve the new vehicles on the detectors

    :param traci: TraCI instance
    :return: dict with the direction and the number of vehicle passing per each controlled lane
    :rtype: dict
    """
    # Retrieve detectors
    detectors = get_all_detectors(traci)

    # Dict with vehicles per direction
    vehicles_per_direction = dict()

    # Iterate over the detectors
    for detector in detectors:

        # Get the current passing vehicles
        cur_veh = set(traci.inductionloop.getLastStepVehicleIDs(detector))

        if cur_veh:

            # North
            if 'north' in detector:
                vehicles_per_direction['north'] = list(cur_veh)
            # East
            elif 'east' in detector:
                vehicles_per_direction['east'] = list(cur_veh)
            # South
            elif 'south' in detector:
                vehicles_per_direction['south'] = list(cur_veh)
            # West
            elif 'west' in detector:
                vehicles_per_direction['west'] = list(cur_veh)

    return vehicles_per_direction


def update_route_with_turns(traci, traffic_info, rows, cols, turn_prob):
    """
    Update the route of the vehicles that have passed the detectors in order to perform turns

    :param traci: TraCI instance
    :param traffic_info: dict with the number of vehicles directions per traffic light
    :type traffic_info: dict
    :param rows: number of topology rows
    :type rows: int
    :param cols: number of topology cols
    :type cols: int
    :param turn_prob: probabilities of turning
    :type turn_prob: pd.DataFrame
    """
    # Retrieve probabilities
    turn_prob_right, turn_prob_left, turn_prob_forward = turn_prob.values.T.tolist()
    # Calculate ranges
    turn_prob_right = turn_prob_right + turn_prob_forward
    turn_prob_left = turn_prob_left + turn_prob_right + turn_prob_forward

    # Retrieve current vehicles
    cur_vehicles = get_new_vehicles(traci)
    # Iterate over the vehicles
    for direction, vehicles in cur_vehicles.items():
        for vehicle in vehicles:
            # Get closest junction
            next_traffic_light = traci.vehicle.getNextTLS(vehicle)[0][0]
            if vehicle not in traffic_info[next_traffic_light]['veh_passed']:
                # Retrieve turn type [0.0, 1.0)
                turn_type = random.random()
                # Retrieve randomly the target edge # TODO update this to be topology dependent (the 2 value)
                target = random.randint(0, 2)
                # Create a possible targets list
                possible_target = list()
                # If the vehicle has a next TLS
                if next_traffic_light:
                    if turn_type < turn_prob_forward:  # straight
                        # Increase the TL straight counter
                        traffic_info[next_traffic_light]['turning_vehicles']['forward'] += 1
                    elif turn_type < turn_prob_right:  # right
                        if 'north' in direction:
                            # Example with 3x3 topology: ['c3_e1', 'c6_e2', 'c9_e3']
                            possible_target = [f'c{cols * i}_e{i}' for i in range(1, rows + 1)]
                        elif 'east' in direction:
                            # Example with 3x3 topology: ['c7_s1', 'c8_s2', 'c9_s3']
                            possible_target = [f'c{cols * (rows - 1) + i}_s{i}' for i in range(1, cols + 1)]
                        elif 'south' in direction:
                            # Example with 3x3 topology: ['c1_w1', 'c4_w2', 'c7_w3']
                            possible_target = [f'c{(i - 1) * cols + 1}_w{i}' for i in range(1, rows + 1)]
                        elif 'west' in direction:
                            # Example with 3x3 topology: ['c1_n1', 'c2_n2', 'c3_n3']
                            possible_target = [f'c{i}_n{i}' for i in range(1, cols + 1)]
                    elif turn_type < turn_prob_left:  # left
                        if 'north' in direction:
                            # Example with 3x3 topology: ['c1_w1', 'c4_w2', 'c7_w3']
                            possible_target = [f'c{(i - 1) * cols + 1}_w{i}' for i in range(1, rows + 1)]
                        elif 'east' in direction:
                            # Example with 3x3 topology: ['c1_n1', 'c2_n2', 'c3_n3']
                            possible_target = [f'c{i}_n{i}' for i in range(1, cols + 1)]
                        elif 'south' in direction:
                            # Example with 3x3 topology: ['c3_e1', 'c6_e2', 'c9_e3']
                            possible_target = [f'c{cols * i}_e{i}' for i in range(1, rows + 1)]
                        elif 'west' in direction:
                            # Example with 3x3 topology: ['c7_s1', 'c8_s2', 'c9_s3']
                            possible_target = [f'c{cols * (rows - 1) + i}_s{i}' for i in range(1, cols + 1)]

                    # Calculate is the target is valid
                    if possible_target:
                        # Get the vehicle route
                        vehicle_route = traci.vehicle.getRoute(vehicle)
                        # Check if the current lane is on the second last lane. Which means that it is at the end of its
                        # route so it can not go to any other target. Otherwise, update the target route
                        if not traci.vehicle.getRoadID(vehicle) == vehicle_route[-2]:
                            traci.vehicle.changeTarget(vehicle, possible_target[target])

                            if turn_type < turn_prob_right:  # right
                                # Increase the TL right counter
                                traffic_info[next_traffic_light]['turning_vehicles']['right'] += 1
                            elif turn_type < turn_prob_left:  # left
                                # Increase the TL left counter
                                traffic_info[next_traffic_light]['turning_vehicles']['left'] += 1

                            # Count new vehicle
                            traffic_info[next_traffic_light]['veh_passed'].add(vehicle)


def calculate_turning_vehicles(traci, traffic_info, rows, cols):
    """
    Calculate the turning vehicles based on its route

    :param traci: TraCI instance
    :param traffic_info: dict with the number of vehicles directions per traffic light
    :type traffic_info: dict
    :param rows: number of topology rows
    :type rows: int
    :param cols: number of topology cols
    :type cols: int
    """

    # Retrieve current vehicles
    cur_vehicles = get_new_vehicles(traci)
    # Iterate over the vehicles
    for direction, vehicles in cur_vehicles.items():
        for vehicle in vehicles:
            # Get closest junction
            next_traffic_light = traci.vehicle.getNextTLS(vehicle)[0][0]
            if vehicle not in traffic_info[next_traffic_light]['veh_passed']:
                # Retrieve vehicle route and current edge
                veh_route = traci.vehicle.getRoute(vehicle)
                cur_edge_index = traci.vehicle.getRouteIndex(vehicle)
                if cur_edge_index != len(veh_route):
                    # Get the next edge
                    next_edge = veh_route[cur_edge_index + 1]
                    # If the vehicle has a next TLS
                    if next_traffic_light:
                        if 'north' in direction:
                            # Turn to right
                            if next_edge in next_edge in [f'c{cols * i}_e{i}' for i in range(1, rows + 1)]:
                                # Increase the TL right counter
                                traffic_info[next_traffic_light]['turning_vehicles']['right'] += 1
                            # Turn left
                            elif next_edge in [f'c{(i - 1) * cols + 1}_w{i}' for i in range(1, rows + 1)]:
                                # Increase the TL left counter
                                traffic_info[next_traffic_light]['turning_vehicles']['left'] += 1
                            # Straight
                            elif next_edge in [f'c{i}_c{i - cols}' for i in range(1, (rows * cols) + 1)]:
                                # Increase the TL straight counter
                                traffic_info[next_traffic_light]['turning_vehicles']['forward'] += 1
                        elif 'east' in direction:
                            # Turn to right
                            if next_edge in [f'c{cols * (rows - 1) + i}_s{i}' for i in range(1, cols + 1)]:
                                # Increase the TL right counter
                                traffic_info[next_traffic_light]['turning_vehicles']['right'] += 1
                            # Turn left
                            elif next_edge in [f'c{i}_n{i}' for i in range(1, cols + 1)]:
                                # Increase the TL left counter
                                traffic_info[next_traffic_light]['turning_vehicles']['left'] += 1
                            # Straight
                            elif next_edge in [f'c{i}_c{i + 1}' for i in range(1, (rows * cols) + 1)]:
                                # Increase the TL straight counter
                                traffic_info[next_traffic_light]['turning_vehicles']['forward'] += 1
                        elif 'south' in direction:
                            if next_edge in [f'c{(i - 1) * cols + 1}_w{i}' for i in range(1, rows + 1)]:
                                # Increase the TL right counter
                                traffic_info[next_traffic_light]['turning_vehicles']['right'] += 1
                            # Turn left
                            elif next_edge in [f'c{cols * i}_e{i}' for i in range(1, rows + 1)]:
                                # Increase the TL left counter
                                traffic_info[next_traffic_light]['turning_vehicles']['left'] += 1
                            # Straight
                            elif next_edge in [f'c{i}_c{i + cols}' for i in range(1, (rows * cols) + 1)]:
                                # Increase the TL straight counter
                                traffic_info[next_traffic_light]['turning_vehicles']['forward'] += 1
                        elif 'west' in direction:
                            if next_edge in [f'c{i}_n{i}' for i in range(1, cols + 1)]:
                                # Increase the TL right counter
                                traffic_info[next_traffic_light]['turning_vehicles']['right'] += 1
                            # Turn left
                            elif next_edge in [f'c{cols * (rows - 1) + i}_s{i}' for i in range(1, cols + 1)]:
                                # Increase the TL left counter
                                traffic_info[next_traffic_light]['turning_vehicles']['left'] += 1
                            # Straight
                            elif next_edge in [f'c{i}_c{i - 1}' for i in range(1, (rows * cols) + 1)]:
                                # Increase the TL straight counter
                                traffic_info[next_traffic_light]['turning_vehicles']['forward'] += 1
                    # Count new vehicle
                    traffic_info[next_traffic_light]['veh_passed'].add(vehicle)


# Simulation related utils
def process_payload(traffic_info, date_info):
    # Format to be Telegraf valid
    traffic_info_payload = list()
    for traffic_light_id, tl_info in traffic_info.items():
        # Remove "veh_passed" key from traffic_info dict
        tl_info.pop("veh_passed", None)
        # Store the concatenation of both dicts
        traffic_info_payload.append(dict({'tl_id': traffic_light_id}, **dict(tl_info), **dict(date_info)))

    return traffic_info_payload


def retrieve_date_info(timestep, time_pattern):
    # Calculate the time pattern id
    time_pattern_id = math.floor(timestep / TIMESTEPS_PER_HALF_HOUR)

    date_info = dict()

    # If next time pattern
    if time_pattern_id < len(time_pattern.pattern):

        # Store year, month, week, day and hour
        cur_hour = time_pattern.get_cur_hour(time_pattern_id)
        if cur_hour:
            date_info["hour"] = cur_hour

        cur_day = time_pattern.get_cur_day(time_pattern_id)
        if cur_day:
            date_info["day"] = cur_day
        else:
            date_info["day"] = DEFAULT_DAY

        cur_date_day = time_pattern.get_cur_date_day(time_pattern_id)
        if cur_date_day:
            date_info["date_day"] = cur_date_day
        else:
            date_info["date_day"] = DEFAULT_DATE_DAY

        cur_month = time_pattern.get_cur_month(time_pattern_id)
        if cur_month:
            date_info["date_month"] = cur_month
        else:
            date_info["date_month"] = DEFAULT_DATE_MONTH

        cur_year = time_pattern.get_cur_year(time_pattern_id)
        if cur_year:
            date_info["date_year"] = cur_year
        else:
            date_info["date_year"] = DEFAULT_DATE_YEAR

    return date_info


def update_current_waiting_time(traci, prev_total_waiting_time_per_lane, traffic_info, cols):
    current_total_waiting_time = get_total_waiting_time_per_lane(traci)
    # Iterate over the current time on lanes
    for junction, lanes in current_total_waiting_time.items():
        for lane, waiting_time in lanes.items():
            # Store when the waiting time is calculated
            if prev_total_waiting_time_per_lane[junction][lane] > waiting_time:
                # Store by direction
                if 'n' in lane or 's' in lane:
                    traffic_info[junction]['waiting_time_veh_n_s'] += \
                        prev_total_waiting_time_per_lane[junction][lane]
                if 'e' in lane or 'w' in lane:
                    traffic_info[junction]['waiting_time_veh_e_w'] += \
                        prev_total_waiting_time_per_lane[junction][lane]
                elif 'c' in lane:
                    # Retrieve the traffic lights
                    prev_traffic_light, next_traffic_light, _ = lane.split('_')

                    # Get the TL identifiers
                    prev_tl_id = int(prev_traffic_light[1:])
                    next_tl_id = int(next_traffic_light[1:])

                    # North-South
                    if prev_tl_id + cols == next_tl_id or \
                            prev_tl_id - cols == next_tl_id:
                        traffic_info[junction]['waiting_time_veh_n_s'] += \
                            prev_total_waiting_time_per_lane[junction][lane]
                    # East-West
                    elif prev_tl_id + 1 == next_tl_id or prev_tl_id - 1 == next_tl_id:
                        traffic_info[junction]['waiting_time_veh_e_w'] += \
                            prev_total_waiting_time_per_lane[junction][lane]

        return current_total_waiting_time


def update_passing_vehicles(traci, traffic_info, passing_veh):
    num_passing_vehicles_detectors = get_num_passing_vehicles_detectors(traci, passing_veh)

    # Update number of vehicles passing
    for traffic_light, info in num_passing_vehicles_detectors.items():
        # Increase the direction counters
        traffic_info[traffic_light]['passing_veh_n_s'] += info['north'] + info['south']
        traffic_info[traffic_light]['passing_veh_e_w'] += info['east'] + info['west']
