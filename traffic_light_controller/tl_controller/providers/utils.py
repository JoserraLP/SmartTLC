# UTILS

import math
import random


def get_topology_dim(traci):
    """
    Retrieve the dimensions of the network topology. Only one number representing both dimensions as it is a regular
    topology matrix

    :param traci: TraCI instance
    :return dict with TL ids and its controlled lanes
    :rtype int
    """
    # Retrieve those valid edges (without ':' character as those are generated by sumo in junctions)
    num_edges = len([x for x in traci.edge.getIDList() if ":" not in x])
    # Calculate the dimension of the topology based on the number of edges
    dim = int(-1 + math.sqrt(1 + 2 * num_edges) / 2)
    return dim


def get_all_controlled_lanes(traci):
    """
    Retrieve all the controlled lanes by the different traffic lights.

    :param traci: TraCI instance
    :return dict with TL ids and its controlled lanes
    :rtype dict
    """
    return {tl_id: list(dict.fromkeys(traci.trafficlight.getControlledLanes(tl_id)))
            for tl_id in traci.trafficlight.getIDList()}


def get_all_detectors(traci):
    """
    Retrieve all the detectors.

    :param traci: TraCI instance
    :return list with the detectors
    :rtype list
    """
    return traci.inductionloop.getIDList()


def get_traffic_light_number(traci):
    """
    Retrieve the number of traffic lights in the simulation.

    :param traci: TraCI instance
    :return: number of traffic lights
    :rtype: int
    """
    return len(traci.trafficlight.getIDList())


def get_total_waiting_time_per_lane(traci):
    """
    Retrieve the waiting time of each lane related to each traffic lights.

    :param traci: TraCI instance
    :return: dict with the TL id and the waiting time per each controlled lane
    :rtype: dict
    """
    # Retrieve lanes
    lanes = get_all_controlled_lanes(traci)

    # Initialize the dict
    lanes_waiting_time = {}

    # Iterate over the different lanes
    for tl_id, tl_lanes in lanes.items():
        # Create the dict per each traffic light
        lanes_waiting_time[tl_id] = {}

        # Calculate and store the waiting time per lane
        for lane in tl_lanes:
            lanes_waiting_time[tl_id][lane] = traci.lane.getWaitingTime(lane)

    return lanes_waiting_time


def get_num_passing_vehicles_detectors(traci, vehicles_passed: dict):
    """
    Retrieve the number of vehicles passing detectors on each direction related to each traffic lights.

    :param vehicles_passed: dict with set of ids of the vehicles that has been counted per traffic light
    :type vehicles_passed: dict
    :param traci: TraCI instance
    :return: dict with the direction and the number of vehicle passing per each controlled lane
    :rtype: dict
    """
    # Retrieve detectors
    detectors = get_all_detectors(traci)

    # Create a dict with the accumulate of vehicles per direction
    passing_veh = {traffic_light: {'north': 0, 'east': 0, 'south': 0, 'west': 0} for traffic_light
                   in traci.trafficlight.getIDList()}

    # Iterate over the detectors
    for detector in detectors:

        # Get traffic light name = lane name
        detector_tl = traci.inductionloop.getLaneID(detector).split('_')[1]

        # Get detector direction
        detector_direction = detector.split('_')[0]

        # Get the current passing vehicles
        cur_veh = set(traci.inductionloop.getLastStepVehicleIDs(detector))

        # Calculate the difference between the sets
        not_counted_veh = cur_veh - vehicles_passed[detector_tl]

        # If there are no counted vehicles
        if not_counted_veh:
            # Add the not counted vehicles
            vehicles_passed[detector_tl].update(not_counted_veh)

            passing_veh[detector_tl][detector_direction] += len(not_counted_veh)

    return passing_veh


def get_new_vehicles(traci):
    """
    Retrieve the new vehicles on the detectors

    :param traci: TraCI instance
    :return: dict with the direction and the number of vehicle passing per each controlled lane
    :rtype: dict
    """
    # Retrieve detectors
    detectors = get_all_detectors(traci)

    # Dict with vehicles per direction
    vehicles_per_direction = dict()

    # Iterate over the detectors
    for detector in detectors:

        # Get the current passing vehicles
        cur_veh = set(traci.inductionloop.getLastStepVehicleIDs(detector))

        if cur_veh:

            # North
            if 'north' in detector:
                vehicles_per_direction['north'] = list(cur_veh)
            # East
            elif 'east' in detector:
                vehicles_per_direction['east'] = list(cur_veh)
            # South
            elif 'south' in detector:
                vehicles_per_direction['south'] = list(cur_veh)
            # West
            elif 'west' in detector:
                vehicles_per_direction['west'] = list(cur_veh)

    return vehicles_per_direction


def update_route_with_turns(traci, turning_vehicles):
    """
    Update the route of the vehicles that have passed the detectors in order to perform turns

    :param traci: TraCI instance
    :param turning_vehicles: dict with the number of vehicles directions per traffic light
    :type turning_vehicles: dict
    """
    # Get topology dimension
    dim = get_topology_dim(traci)

    # Retrieve current vehicles
    cur_vehicles = get_new_vehicles(traci)
    # Iterate over the vehicles
    for direction, vehicles in cur_vehicles.items():
        for vehicle in vehicles:
            # Retrieve turn type
            turn_type = random.randint(0, 100)
            # Get closest junction
            next_traffic_light = traci.vehicle.getNextTLS(vehicle)[0][0]
            # Retrieve randomly the target edge
            target = random.randint(0, 2)
            # Create a possible targets list
            possible_target = list()
            # If the vehicle has a next TLS
            if next_traffic_light:
                if turn_type < 60:  # straight
                    # Increase the TL straight counter
                    turning_vehicles[next_traffic_light]['turning_vehicles']['forward'] += 1
                elif turn_type < 80:  # right
                    # Increase the TL right counter
                    turning_vehicles[next_traffic_light]['turning_vehicles']['right'] += 1
                    if 'north' in direction:
                        # Example with 3x3 topology: ['c1_w1', 'c4_w2', 'c7_w3']
                        possible_target = [f'c{dim * i - dim + 1}_w{i}' for i in range(1, dim + 1)]
                    elif 'east' in direction:
                        # Example with 3x3 topology: ['c7_n1', 'c8_n2', 'c9_n3']
                        possible_target = [f'c{dim * (dim - 1) + i}_n{i}' for i in range(1, dim + 1)]
                    elif 'south' in direction:
                        # Example with 3x3 topology: ['c3_e1', 'c6_e2', 'c9_e3']
                        possible_target = [f'c{dim * i}_e{i}' for i in range(1, dim + 1)]
                    elif 'west' in direction:
                        # Example with 3x3 topology: ['c1_s1', 'c2_s2', 'c3_s3']
                        possible_target = [f'c{i}_s{i}' for i in range(1, dim + 1)]
                elif turn_type < 100:  # left
                    # Increase the TL left counter
                    turning_vehicles[next_traffic_light]['turning_vehicles']['left'] += 1
                    if 'north' in direction:
                        # Example with 3x3 topology: ['c3_e1', 'c6_e2', 'c9_e3']
                        possible_target = [f'c{i * dim}_e{i}' for i in range(1, dim + 1)]
                    elif 'east' in direction:
                        # Example with 3x3 topology: ['c1_s1', 'c2_s2', 'c3_s3']
                        possible_target = [f'c{i}_s{i}' for i in range(1, dim + 1)]
                    elif 'south' in direction:
                        # Example with 3x3 topology: ['c1_w1', 'c4_w2', 'c7_w3']
                        possible_target = [f'c{dim * i - dim + 1}_w{i}' for i in range(1, dim + 1)]
                    elif 'west' in direction:
                        # Example with 3x3 topology: ['c7_n1', 'c8_n2', 'c9_n3']
                        possible_target = [f'c{dim * (dim - 1) + i}_n{i}' for i in range(1, dim + 1)]

                # Calculate is the target is valid
                if possible_target:
                    # Get the vehicle route
                    vehicle_route = traci.vehicle.getRoute(vehicle)
                    # Check if the current lane is on the second last lane. Which means that it is at the end of its 
                    # route so it can not go to any other target. Otherwise, update the target route
                    if not traci.vehicle.getRoadID(vehicle) == vehicle_route[-2]:
                        traci.vehicle.changeTarget(vehicle, possible_target[target])

def calculate_turning_vehicles(traci, turning_vehicles):
    """
    Calculate the turning vehicles based on its route

    :param traci: TraCI instance
    :param turning_vehicles: dict with the number of vehicles directions per traffic light
    :type turning_vehicles: dict
    """
    # Get topology dimension
    dim = get_topology_dim(traci)

    # Retrieve current vehicles
    cur_vehicles = get_new_vehicles(traci)
    # Iterate over the vehicles
    for direction, vehicles in cur_vehicles.items():
        for vehicle in vehicles:
            # Get closest junction
            next_traffic_light = traci.vehicle.getNextTLS(vehicle)[0][0]
            # Retrieve vehicle route and current edge
            veh_route = traci.vehicle.getRoute(vehicle)
            cur_edge_index = traci.vehicle.getRouteIndex(vehicle)
            if cur_edge_index == len(veh_route):
                cur_edge_index -= 1
            # Get the next edge
            next_edge = veh_route[cur_edge_index+1]
            # If the vehicle has a next TLS
            if next_traffic_light:
                if 'north' in direction:
                    # Turn to right
                    if next_edge in [f'c{dim * i - dim + 1}_w{i}' for i in range(1, dim + 1)]:
                        # Increase the TL right counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['right'] += 1
                    # Turn left
                    elif next_edge in [f'c{i * dim}_e{i}' for i in range(1, dim + 1)]:
                        # Increase the TL left counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['left'] += 1
                    # Straight
                    else:
                        # Increase the TL straight counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['forward'] += 1
                elif 'east' in direction:
                    # Turn to right
                    if next_edge in [f'c{dim * (dim - 1) + i}_n{i}' for i in range(1, dim + 1)]:
                        # Increase the TL right counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['right'] += 1
                    # Turn left
                    elif next_edge in [f'c{i}_s{i}' for i in range(1, dim + 1)]:
                        # Increase the TL left counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['left'] += 1
                    # Straight
                    else:
                        # Increase the TL straight counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['forward'] += 1
                elif 'south' in direction:
                    if next_edge in [f'c{dim * i}_e{i}' for i in range(1, dim + 1)]:
                        # Increase the TL right counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['right'] += 1
                    # Turn left
                    elif next_edge in [f'c{dim * i - dim + 1}_w{i}' for i in range(1, dim + 1)]:
                        # Increase the TL left counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['left'] += 1
                    # Straight
                    else:
                        # Increase the TL straight counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['forward'] += 1
                elif 'west' in direction:
                    if next_edge in [f'c{i}_s{i}' for i in range(1, dim + 1)]:
                        # Increase the TL right counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['right'] += 1
                    # Turn left
                    elif next_edge in [f'c{dim * (dim - 1) + i}_n{i}' for i in range(1, dim + 1)]:
                        # Increase the TL left counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['left'] += 1
                    # Straight
                    else:
                        # Increase the TL straight counter
                        turning_vehicles[next_traffic_light]['turning_vehicles']['forward'] += 1
