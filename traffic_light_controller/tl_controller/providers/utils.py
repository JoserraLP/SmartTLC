# UTILS

import math
import random

import pandas as pd

from tl_controller.static.constants import *


def parse_str_to_valid_schema(input_info):
    return str(input_info).replace('\'', '\"').replace(" ", "")


def get_topology_dim(traci):
    """
    Retrieve the dimensions of the network topology. Only one number representing both dimensions as it is a regular
    topology matrix

    :param traci: TraCI instance
    :return dict with TL ids and its controlled lanes
    :rtype int
    """
    # Retrieve those valid edges (without ':' character as those are generated by sumo in junctions)
    valid_edges = [x for x in traci.edge.getIDList() if ":" not in x]

    # Retrieve number of north (or south) edges to retrieve number of cols
    # (divided by two as there are to edges per road)
    cols = len([x for x in valid_edges if "n" in x]) / 2
    # Retrieve number of west (or west) edges to retrieve number of rows
    # (divided by two as there are to edges per road)
    rows = len([x for x in valid_edges if "w" in x]) / 2

    return int(rows), int(cols)


def get_all_controlled_lanes(traci):
    """
    Retrieve all the controlled lanes by the different traffic lights.

    :param traci: TraCI instance
    :return dict with TL ids and its controlled lanes
    :rtype dict
    """
    return {tl_id: list(dict.fromkeys(traci.trafficlight.getControlledLanes(tl_id)))
            for tl_id in traci.trafficlight.getIDList()}


def get_all_detectors(traci):
    """
    Retrieve all the detectors.

    :param traci: TraCI instance
    :return list with the detectors
    :rtype list
    """
    return traci.inductionloop.getIDList()


def get_traffic_light_number(traci):
    """
    Retrieve the number of traffic lights in the simulation.

    :param traci: TraCI instance
    :return: number of traffic lights
    :rtype: int
    """
    return len(traci.trafficlight.getIDList())


def get_total_waiting_time_per_lane(traci):
    """
    Retrieve the waiting time of each lane related to each traffic lights.

    :param traci: TraCI instance
    :return: dict with the TL id and the waiting time per each controlled lane
    :rtype: dict
    """
    # Retrieve lanes
    lanes = get_all_controlled_lanes(traci)

    # Initialize the dict
    lanes_waiting_time = {}

    # Iterate over the different lanes
    for tl_id, tl_lanes in lanes.items():
        # Create the dict per each traffic light
        lanes_waiting_time[tl_id] = {}

        # Calculate and store the waiting time per lane
        for lane in tl_lanes:
            lanes_waiting_time[tl_id][lane] = traci.lane.getWaitingTime(lane)

    return lanes_waiting_time


def get_num_passing_vehicles_detectors(traci, traffic_info: dict):
    """
    Retrieve the number of vehicles passing detectors on each direction related to each traffic lights.

    :param traffic_info: dict with set of ids of the vehicles that has been counted per traffic light
    :type traffic_info: dict
    :param traci: TraCI instance
    :return: dict with the direction and the number of vehicle passing per each controlled lane
    :rtype: dict
    """
    # Retrieve detectors
    detectors = get_all_detectors(traci)

    # Create a dict with the accumulate of vehicles per direction
    passing_veh = {traffic_light: {'north': 0, 'east': 0, 'south': 0, 'west': 0} for traffic_light
                   in traci.trafficlight.getIDList()}

    # Iterate over the detectors
    for detector in detectors:

        # Get traffic light name = lane name
        detector_tl = traci.inductionloop.getLaneID(detector).split('_')[1]

        # Get detector direction
        detector_direction = detector.split('_')[0]

        # Get the current passing vehicles
        cur_veh = set(traci.inductionloop.getLastStepVehicleIDs(detector))

        # Calculate the difference between the sets
        not_counted_veh = cur_veh - traffic_info[detector_tl]['veh_passed']

        # If there are no counted vehicles
        if not_counted_veh:
            # Add the not counted vehicles
            traffic_info[detector_tl]['veh_passed'].update(not_counted_veh)

            passing_veh[detector_tl][detector_direction] += len(not_counted_veh)

    return passing_veh


def update_passing_vehicles(traci, traffic_info, rows, cols):
    num_passing_vehicles_detectors = get_num_passing_vehicles_detectors(traci, traffic_info)

    # Update number of vehicles passing
    for traffic_light, info in num_passing_vehicles_detectors.items():
        # Increase the direction counters
        traffic_info[traffic_light]['passing_veh_n_s'] += info['north'] + info['south']
        traffic_info[traffic_light]['passing_veh_e_w'] += info['east'] + info['west']


def update_current_waiting_time(traci, prev_total_waiting_time_per_lane, traffic_info, cols):
    current_total_waiting_time = get_total_waiting_time_per_lane(traci)
    # Iterate over the current time on lanes
    for junction, lanes in current_total_waiting_time.items():
        for lane, waiting_time in lanes.items():
            # Store when the waiting time is calculated (Next value is 0, meaning it has passed)
            if prev_total_waiting_time_per_lane[junction][lane] > waiting_time:

                # Retrieve the traffic lights
                origin, destination, _ = lane.split('_')

                if ('n' in destination or ('s' in origin and 'c' in destination)) or \
                        ('s' in destination or ('n' in origin and 'c' in destination)):
                    traffic_info[junction]['waiting_time_veh_n_s'] += \
                        prev_total_waiting_time_per_lane[junction][lane]
                if ('e' in destination or ('w' in origin and 'c' in destination)) or \
                        ('w' in destination or ('e' in origin and 'c' in destination)):
                    traffic_info[junction]['waiting_time_veh_e_w'] += \
                        prev_total_waiting_time_per_lane[junction][lane]
                if 'c' in origin and 'c' in destination:
                    # Get the TL identifiers
                    prev_tl_id = int(origin[1:])
                    next_tl_id = int(destination[1:])

                    # North-South
                    if prev_tl_id + cols == next_tl_id or \
                            prev_tl_id - cols == next_tl_id:
                        traffic_info[junction]['waiting_time_veh_n_s'] += \
                            prev_total_waiting_time_per_lane[junction][lane]
                    # East-West
                    elif prev_tl_id + 1 == next_tl_id or prev_tl_id - 1 == next_tl_id:
                        traffic_info[junction]['waiting_time_veh_e_w'] += \
                            prev_total_waiting_time_per_lane[junction][lane]

    return current_total_waiting_time


def get_new_vehicles(traci):
    """
    Retrieve the new vehicles on the detectors

    :param traci: TraCI instance
    :return: dict with the direction and the number of vehicle passing per each controlled lane
    :rtype: dict
    """
    # Retrieve detectors
    detectors = get_all_detectors(traci)

    # Dict with vehicles per direction
    vehicles_per_direction = dict()

    # Iterate over the detectors
    for detector in detectors:

        # Get the current passing vehicles
        cur_veh = set(traci.inductionloop.getLastStepVehicleIDs(detector))

        if cur_veh:

            # North
            if 'north' in detector:
                vehicles_per_direction['north'] = list(cur_veh)
            # East
            elif 'east' in detector:
                vehicles_per_direction['east'] = list(cur_veh)
            # South
            elif 'south' in detector:
                vehicles_per_direction['south'] = list(cur_veh)
            # West
            elif 'west' in detector:
                vehicles_per_direction['west'] = list(cur_veh)

    return vehicles_per_direction


def update_route_with_turns_by_junction(traci, traffic_info, rows, cols, turn_prob):
    """
    Update the route of the vehicles that have passed the detectors in order to perform turns

    :param traci: TraCI instance
    :param traffic_info: dict with the number of vehicles directions per traffic light
    :type traffic_info: dict
    :param rows: number of topology rows
    :type rows: int
    :param cols: number of topology cols
    :type cols: int
    :param turn_prob: probabilities of turning
    :type turn_prob: pd.DataFrame
    """

    # Retrieve probabilities
    turn_prob_right, turn_prob_left, turn_prob_forward, junction_id = turn_prob.values.T.tolist()

    # Get all junctions
    all_junctions = [f'c{i}' for i in range(1, get_traffic_light_number(traci) + 1)]

    prod_by_junctions = {}
    # Same probabilities to all junctions
    if junction_id == 'all':
        for index, junction in enumerate(all_junctions):
            prod_by_junctions[junction] = {'turn_prob_right': float(turn_prob_right) + float(turn_prob_forward),
                                           'turn_prob_left': float(turn_prob_left) + float(turn_prob_right) +
                                                             float(turn_prob_forward),
                                           'turn_prob_forward': float(turn_prob_forward)}
    else:  # Specific probabilities
        turn_prob_right, turn_prob_left, turn_prob_forward, specific_junctions = turn_prob_right.split(';'), \
                                                                                 turn_prob_left.split(';'), \
                                                                                 turn_prob_forward.split(';'), \
                                                                                 junction_id.split(';')
        # Specific junctions
        for index, junction in enumerate(specific_junctions):
            prod_by_junctions[junction] = {'turn_prob_right': float(turn_prob_right[index]) +
                                                              float(turn_prob_forward[index]),
                                           'turn_prob_left': float(turn_prob_left[index]) +
                                                             float(turn_prob_forward[index]) +
                                                             float(turn_prob_right[index]),
                                           'turn_prob_forward': float(turn_prob_forward[index])}

        # Default probabilities (0.0, 0.0, 100.0)
        for index, junction in enumerate(list(set(all_junctions) - set(specific_junctions))):
            prod_by_junctions[junction] = {'turn_prob_right': 0.0, 'turn_prob_left': 0.0, 'turn_prob_forward': 100.0}

    # Retrieve current vehicles
    cur_vehicles = get_new_vehicles(traci)

    # Iterate over the vehicles
    for direction, vehicles in cur_vehicles.items():
        for vehicle in vehicles:
            # Get closest junction
            next_traffic_light = traci.vehicle.getNextTLS(vehicle)[0][0]

            # Initialize target to -1
            target = -1
            # Create a possible targets list
            possible_target = list()
            # Vehicle is not updated yet
            if vehicle not in traffic_info[next_traffic_light]['turning_vehicles']['veh_passed']:
                # Retrieve turn type [0.0, 1.0)
                turn_type = random.random()
                # If the vehicle has a next TLS
                if next_traffic_light:
                    if turn_type < prod_by_junctions[next_traffic_light]['turn_prob_forward']:  # straight
                        # Increase the TL straight counter
                        traffic_info[next_traffic_light]['turning_vehicles']['forward'] += 1
                    elif turn_type < prod_by_junctions[next_traffic_light]['turn_prob_right']:  # right
                        if 'north' in direction:
                            # Example with 3x3 topology: ['c3_e1', 'c6_e2', 'c9_e3']
                            possible_target = [f'c{cols * i}_e{i}' for i in range(1, rows + 1)]
                            # Retrieve random target (based on number of rows)
                            target = random.randint(0, rows - 1)
                        elif 'east' in direction:
                            # Example with 3x3 topology: ['c7_s1', 'c8_s2', 'c9_s3']
                            possible_target = [f'c{cols * (rows - 1) + i}_s{i}' for i in range(1, cols + 1)]
                            # Retrieve random target (based on number of cols)
                            target = random.randint(0, cols - 1)
                        elif 'south' in direction:
                            # Example with 3x3 topology: ['c1_w1', 'c4_w2', 'c7_w3']
                            possible_target = [f'c{(i - 1) * cols + 1}_w{i}' for i in range(1, rows + 1)]
                            # Retrieve random target (based on number of rows)
                            target = random.randint(0, rows - 1)
                        elif 'west' in direction:
                            # Example with 3x3 topology: ['c1_n1', 'c2_n2', 'c3_n3']
                            possible_target = [f'c{i}_n{i}' for i in range(1, cols + 1)]
                            # Retrieve random target (based on number of cols)
                            target = random.randint(0, cols - 1)
                    elif turn_type < prod_by_junctions[next_traffic_light]['turn_prob_left']:  # left
                        if 'north' in direction:
                            # Example with 3x3 topology: ['c1_w1', 'c4_w2', 'c7_w3']
                            possible_target = [f'c{(i - 1) * cols + 1}_w{i}' for i in range(1, rows + 1)]
                            # Retrieve random target (based on number of rows)
                            target = random.randint(0, rows - 1)
                        elif 'east' in direction:
                            # Example with 3x3 topology: ['c1_n1', 'c2_n2', 'c3_n3']
                            possible_target = [f'c{i}_n{i}' for i in range(1, cols + 1)]
                            # Retrieve random target (based on number of cols)
                            target = random.randint(0, cols - 1)
                        elif 'south' in direction:
                            # Example with 3x3 topology: ['c3_e1', 'c6_e2', 'c9_e3']
                            possible_target = [f'c{cols * i}_e{i}' for i in range(1, rows + 1)]
                            # Retrieve random target (based on number of rows)
                            target = random.randint(0, rows - 1)
                        elif 'west' in direction:
                            # Example with 3x3 topology: ['c7_s1', 'c8_s2', 'c9_s3']
                            possible_target = [f'c{cols * (rows - 1) + i}_s{i}' for i in range(1, cols + 1)]
                            # Retrieve random target (based on number of cols)
                            target = random.randint(0, cols - 1)

                    # Calculate if the target is valid
                    if possible_target and target != -1:
                        # Retrieve current lane
                        cur_vehicle_lane = traci.vehicle.getRoadID(vehicle)
                        # Retrieve vehicle type
                        cur_vehicle_type = traci.vehicle.getTypeID(vehicle)
                        # Find new route
                        new_route = traci.simulation.findRoute(fromEdge=cur_vehicle_lane,
                                                               toEdge=possible_target[target],
                                                               vType=cur_vehicle_type).edges

                        # Check if there are routes available (from and to) based on the current vehicle type
                        if new_route:
                            # Set new route
                            traci.vehicle.setRoute(vehicle, new_route)
                            if turn_type < prod_by_junctions[next_traffic_light]['turn_prob_right']:  # right
                                # Increase the TL right counter
                                traffic_info[next_traffic_light]['turning_vehicles']['right'] += 1
                            elif turn_type < prod_by_junctions[next_traffic_light]['turn_prob_left']:  # left
                                # Increase the TL left counter
                                traffic_info[next_traffic_light]['turning_vehicles']['left'] += 1

                            # Count new vehicle
                            traffic_info[next_traffic_light]['turning_vehicles']['veh_passed'].add(vehicle)


def update_route_with_turns(traci, traffic_info, rows, cols, turn_prob):
    """
    Update the route of the vehicles that have passed the detectors in order to perform turns

    :param traci: TraCI instance
    :param traffic_info: dict with the number of vehicles directions per traffic light
    :type traffic_info: dict
    :param rows: number of topology rows
    :type rows: int
    :param cols: number of topology cols
    :type cols: int
    :param turn_prob: probabilities of turning
    :type turn_prob: pd.DataFrame
    """

    # Retrieve probabilities
    turn_prob_right, turn_prob_left, turn_prob_forward, edges_id = turn_prob.values.T.tolist()

    # Get all junctions
    all_edges = [edge for edge in traci.edge.getIDList() if ':' not in edge]

    prod_by_edges = {}
    # Same probabilities to all roads
    if edges_id == 'all':
        for index, edge in enumerate(all_edges):
            prod_by_edges[edge] = {'turn_prob_right': float(turn_prob_right) + float(turn_prob_forward),
                                           'turn_prob_left': float(turn_prob_left) + float(turn_prob_right) +
                                                             float(turn_prob_forward),
                                           'turn_prob_forward': float(turn_prob_forward)}
    else:  # Specific probabilities
        turn_prob_right, turn_prob_left, turn_prob_forward, specific_edges = turn_prob_right.split(';'), \
                                                                                 turn_prob_left.split(';'), \
                                                                                 turn_prob_forward.split(';'), \
                                                                                 edges_id.split(';')
        # Specific junctions
        for index, edge in enumerate(specific_edges):
            prod_by_edges[edge] = {'turn_prob_right': float(turn_prob_right[index]) +
                                                              float(turn_prob_forward[index]),
                                           'turn_prob_left': float(turn_prob_left[index]) +
                                                             float(turn_prob_forward[index]) +
                                                             float(turn_prob_right[index]),
                                           'turn_prob_forward': float(turn_prob_forward[index])}

        # Default probabilities (20.0, 20.0, 60.0)
        for index, edge in enumerate(list(set(all_edges) - set(specific_edges))):
            prod_by_edges[edge] = DEFAULT_TURN_DICT

    # Get all vehicles from simulation
    vehicles = traci.vehicle.getIDList()

    # Iterate over the vehicles
    # for direction, vehicles in cur_vehicles.items():
    for vehicle in vehicles:

        # Get current vehicle road, origin and destination
        vehicle_road = traci.vehicle.getRoadID(vehicle)
        if ':' not in vehicle_road:
            origin, destination = vehicle_road.split('_')
            origin_id = int(origin[1:])
            destination_id = int(destination[1:])

            # Retrieve next traffic light
            next_traffic_light = destination if 'c' in destination else ''

            if next_traffic_light != '':

                target = ''
                # Vehicle is not updated yet
                if vehicle not in traffic_info[next_traffic_light]['turning_vehicles']['veh_passed']:
                    # Retrieve turn type [0.0, 1.0)
                    turn_type = random.random()

                    # TODO reduce boolean logic
                    if turn_type < prod_by_edges[vehicle_road]['turn_prob_forward']:  # straight
                        # Increase the TL straight counter
                        traffic_info[next_traffic_light]['turning_vehicles']['forward'] += 1
                    elif turn_type < prod_by_edges[vehicle_road]['turn_prob_right']:  # right
                        if 'n' in origin:
                            # Left-side roads
                            if destination_id % cols == 1:
                                target = f'c{destination_id}_w{origin_id}'
                            else:
                                target = f'c{destination_id}_c{destination_id-1}'
                        elif 's' in origin:
                            # Right-side roads
                            if destination_id % cols == 0:
                                target = f'c{destination_id}_e{int(destination_id/cols)}'
                            else:
                                target = f'c{destination_id}_c{destination_id+1}'
                        elif 'e' in origin:
                            # Up-side roads
                            if math.ceil(destination_id / cols) == 1:
                                target = f'c{destination_id}_n{cols}'
                            else:
                                target = f'c{destination_id}_c{destination_id-cols}'
                        elif 'w' in origin:
                            # Down-side roads
                            if math.ceil(destination_id / cols) == rows:
                                target = f'c{destination_id}_s1'
                            else:
                                target = f'c{destination_id}_c{destination_id+cols}'
                        elif 'c' in origin and 'c' in destination:
                            # From left to right
                            if origin_id == destination_id-1:
                                # Down-side roads
                                if math.ceil(destination_id / cols) == rows:
                                    target = f'c{destination_id}_s{destination_id-(cols*(rows-1))}'
                                else:
                                    target = f'c{destination_id}_c{destination_id+cols}'
                            # From right to left
                            elif origin_id == destination_id+1:
                                # Up-side roads
                                if math.ceil(destination_id / cols) == 1:
                                    target = f'c{destination_id}_n{destination_id}'
                                else:
                                    target = f'c{destination_id}_c{destination_id-cols}'
                            # From down to up
                            elif origin_id == destination_id + cols:
                                # Right-side roads
                                if destination_id % cols == 0:
                                    target = f'c{destination_id}_e{math.ceil(destination_id/cols)}'
                                else:
                                    target = f'c{destination_id}_c{destination_id + 1}'
                            # From up to down
                            elif origin_id == destination_id - cols:
                                # Left-side roads
                                if destination_id % cols == 1:
                                    target = f'c{destination_id}_w{math.ceil(destination_id/cols)}'
                                else:
                                    target = f'c{destination_id}_c{destination_id - 1}'

                        #print(f"Vehicle {vehicle} turning RIGHT from {vehicle_road} to {target}")

                    elif turn_type < prod_by_edges[vehicle_road]['turn_prob_left']:  # left
                        if 'n' in origin:
                            # Right-side roads
                            if destination_id % cols == 0:
                                target = f'c{destination_id}_e1'
                            else:
                                target = f'c{destination_id}_c{destination_id + 1}'
                        elif 's' in origin:
                            # Left-side roads
                            if destination_id % cols == 1:
                                target = f'c{destination_id}_w{rows}'
                            else:
                                target = f'c{destination_id}_c{destination_id - 1}'
                        elif 'e' in origin:
                            # Down-side roads
                            if math.ceil(destination_id / cols) == rows:
                                target = f'c{destination_id}_s{cols}'
                            else:
                                target = f'c{destination_id}_c{destination_id + cols}'
                        elif 'w' in origin:
                            # Up-side roads
                            if math.ceil(destination_id / cols) == 1:
                                target = f'c{destination_id}_n1'
                            else:
                                target = f'c{destination_id}_c{destination_id - cols}'
                        elif 'c' in origin and 'c' in destination:
                            # From left to right
                            if origin_id == destination_id - 1:
                                # Up-side roads
                                if math.ceil(destination_id / cols) == 1:
                                    target = f'c{destination_id}_n{destination_id}'
                                else:
                                    target = f'c{destination_id}_c{destination_id - cols}'
                            # From right to left
                            elif origin_id == destination_id + 1:
                                # Down-side roads
                                if math.ceil(destination_id / cols) == rows:
                                    target = f'c{destination_id}_s{destination_id%cols}'
                                else:
                                    target = f'c{destination_id}_c{destination_id + cols}'
                            # From down to up
                            elif origin_id == destination_id + cols:
                                # Left-side roads
                                if destination_id % cols == 1:
                                    target = f'c{destination_id}_w{math.ceil(destination_id/cols)}'
                                else:
                                    target = f'c{destination_id}_c{destination_id - 1}'
                            # From up to down
                            elif origin_id == destination_id - cols:
                                # Right-side roads
                                if destination_id % cols == 0:
                                    target = f'c{destination_id}_e{math.ceil(destination_id/cols)}'
                                else:
                                    target = f'c{destination_id}_c{destination_id + 1}'

                        #print(f"Vehicle {vehicle} turning LEFT from {vehicle_road} to {target}")

                    # Calculate if the target is valid
                    if target != '':
                        # Retrieve vehicle type
                        cur_vehicle_type = traci.vehicle.getTypeID(vehicle)
                        # Find new route
                        new_route = traci.simulation.findRoute(fromEdge=vehicle_road,
                                                               toEdge=target,
                                                               vType=cur_vehicle_type).edges

                        # Check if there are routes available (from and to) based on the current vehicle type
                        if new_route:
                            # Set new route
                            traci.vehicle.setRoute(vehicle, new_route)
                            if turn_type < prod_by_edges[vehicle_road]['turn_prob_right']:  # right
                                # Increase the TL right counter
                                traffic_info[next_traffic_light]['turning_vehicles']['right'] += 1
                            elif turn_type < prod_by_edges[vehicle_road]['turn_prob_left']:  # left
                                # Increase the TL left counter
                                traffic_info[next_traffic_light]['turning_vehicles']['left'] += 1

                            # Count new vehicle
                            traffic_info[next_traffic_light]['turning_vehicles']['veh_passed'].add(vehicle)


def calculate_turning_vehicles(traci, traffic_info, rows, cols):
    """
    Calculate the turning vehicles based on its route

    :param traci: TraCI instance
    :param traffic_info: dict with the number of vehicles directions per traffic light
    :type traffic_info: dict
    :param rows: number of topology rows
    :type rows: int
    :param cols: number of topology cols
    :type cols: int
    """

    # Retrieve current vehicles
    cur_vehicles = get_new_vehicles(traci)
    # Iterate over the vehicles
    for direction, vehicles in cur_vehicles.items():
        for vehicle in vehicles:
            # Get closest junction
            next_traffic_light = traci.vehicle.getNextTLS(vehicle)[0][0]
            if vehicle not in traffic_info[next_traffic_light]['turning_vehicles']['veh_passed']:
                # Retrieve vehicle route and current edge
                veh_route = traci.vehicle.getRoute(vehicle)
                cur_edge_index = traci.vehicle.getRouteIndex(vehicle)
                if cur_edge_index != len(veh_route):
                    # Get the next edge
                    next_edge = veh_route[cur_edge_index + 1]
                    # If the vehicle has a next TLS
                    if next_traffic_light:
                        if 'north' in direction:
                            # Turn to right
                            if next_edge in next_edge in [f'c{cols * i}_e{i}' for i in range(1, rows + 1)]:
                                # Increase the TL right counter
                                traffic_info[next_traffic_light]['turning_vehicles']['right'] += 1
                            # Turn left
                            elif next_edge in [f'c{(i - 1) * cols + 1}_w{i}' for i in range(1, rows + 1)]:
                                # Increase the TL left counter
                                traffic_info[next_traffic_light]['turning_vehicles']['left'] += 1
                            # Straight
                            elif next_edge in [f'c{i}_c{i - cols}' for i in range(1, (rows * cols) + 1)]:
                                # Increase the TL straight counter
                                traffic_info[next_traffic_light]['turning_vehicles']['forward'] += 1
                        elif 'east' in direction:
                            # Turn to right
                            if next_edge in [f'c{cols * (rows - 1) + i}_s{i}' for i in range(1, cols + 1)]:
                                # Increase the TL right counter
                                traffic_info[next_traffic_light]['turning_vehicles']['right'] += 1
                            # Turn left
                            elif next_edge in [f'c{i}_n{i}' for i in range(1, cols + 1)]:
                                # Increase the TL left counter
                                traffic_info[next_traffic_light]['turning_vehicles']['left'] += 1
                            # Straight
                            elif next_edge in [f'c{i}_c{i + 1}' for i in range(1, (rows * cols) + 1)]:
                                # Increase the TL straight counter
                                traffic_info[next_traffic_light]['turning_vehicles']['forward'] += 1
                        elif 'south' in direction:
                            if next_edge in [f'c{(i - 1) * cols + 1}_w{i}' for i in range(1, rows + 1)]:
                                # Increase the TL right counter
                                traffic_info[next_traffic_light]['turning_vehicles']['right'] += 1
                            # Turn left
                            elif next_edge in [f'c{cols * i}_e{i}' for i in range(1, rows + 1)]:
                                # Increase the TL left counter
                                traffic_info[next_traffic_light]['turning_vehicles']['left'] += 1
                            # Straight
                            elif next_edge in [f'c{i}_c{i + cols}' for i in range(1, (rows * cols) + 1)]:
                                # Increase the TL straight counter
                                traffic_info[next_traffic_light]['turning_vehicles']['forward'] += 1
                        elif 'west' in direction:
                            if next_edge in [f'c{i}_n{i}' for i in range(1, cols + 1)]:
                                # Increase the TL right counter
                                traffic_info[next_traffic_light]['turning_vehicles']['right'] += 1
                            # Turn left
                            elif next_edge in [f'c{cols * (rows - 1) + i}_s{i}' for i in range(1, cols + 1)]:
                                # Increase the TL left counter
                                traffic_info[next_traffic_light]['turning_vehicles']['left'] += 1
                            # Straight
                            elif next_edge in [f'c{i}_c{i - 1}' for i in range(1, (rows * cols) + 1)]:
                                # Increase the TL straight counter
                                traffic_info[next_traffic_light]['turning_vehicles']['forward'] += 1
                    # Count new vehicle
                    traffic_info[next_traffic_light]['turning_vehicles']['veh_passed'].add(vehicle)


# Simulation related utils
def process_payload(traffic_info, date_info):
    # Format to be Telegraf valid
    traffic_info_payload = list()
    for traffic_light_id, tl_info in traffic_info.items():
        if traffic_light_id != 'summary':
            # Remove "veh_passed" key from traffic_info dict
            tl_info.pop("veh_passed", None)
            # Remove also the "veh_passed" key from the turning vehicles
            tl_info['turning_vehicles'].pop("veh_passed", None)
            # Store the concatenation of both dicts
        traffic_info_payload.append(dict({'tl_id': traffic_light_id}, **dict(tl_info), **dict(date_info)))

    return traffic_info_payload


def retrieve_date_info(timestep, time_pattern):
    # Calculate the time pattern id
    time_pattern_id = math.floor(timestep / TIMESTEPS_PER_HALF_HOUR)

    date_info = dict()

    # If next time pattern
    if time_pattern_id < len(time_pattern.pattern):

        # Store year, month, week, day and hour
        cur_hour = time_pattern.get_cur_hour(time_pattern_id)
        if cur_hour:
            date_info["hour"] = cur_hour

        cur_day = time_pattern.get_cur_day(time_pattern_id)
        if cur_day:
            date_info["day"] = cur_day
        else:
            date_info["day"] = DEFAULT_DAY

        cur_date_day = time_pattern.get_cur_date_day(time_pattern_id)
        if cur_date_day:
            date_info["date_day"] = cur_date_day
        else:
            date_info["date_day"] = DEFAULT_DATE_DAY

        cur_month = time_pattern.get_cur_month(time_pattern_id)
        if cur_month:
            date_info["date_month"] = cur_month
        else:
            date_info["date_month"] = DEFAULT_DATE_MONTH

        cur_year = time_pattern.get_cur_year(time_pattern_id)
        if cur_year:
            date_info["date_year"] = cur_year
        else:
            date_info["date_year"] = DEFAULT_DATE_YEAR

    return date_info
